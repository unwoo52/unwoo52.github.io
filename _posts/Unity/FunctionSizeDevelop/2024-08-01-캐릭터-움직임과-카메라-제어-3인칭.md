---
title: 캐릭터 움직임과 카메라 제어 3인칭
author: unwoo52
date: 2024-08-01 00:00:00 +09:00
categories: [Unity]
tags: [Unity, Function, FunctionSizeDev, Actor, Camera, ThirdPerson]
---

플레이어 캐릭터를 따라다니는 3인칭 시점 카메라와 캐릭터 움직임을 구현하고자 한다.

캐릭터는 카메라의 방향과 독립적으로 움직인다. 'DEAD BY DAYLIGHT' 게임이나 '배틀그라운드'와 같이 뒤를 보면서 앞으로 달리는게 가능한 형태이다.


### ThirdPersonCamera.cs

```csharp
using UnityEngine;
using UnityEngine.InputSystem;

public class ThirdPersonCamera : MonoBehaviour
{
    [SerializeField] float mouseSensitivity;
    [SerializeField] [Range(-85,85)] float minRotateY = -85;
    [SerializeField] [Range(-85,85)] float maxRotateY = 85;
    float _mouseInputX; // yaw, x입력값 (y축 회전)
    float _mouseInputY; // pitch, y 입력값 (z축 회전)

    public void MouseInput(InputAction.CallbackContext context)
    {
        Vector2 delta = context.ReadValue<Vector2>();
        OnRotateCamera(delta);
    }

    public void OnRotateCamera(Vector2 delta)
    {
        float dt = Time.deltaTime;

        _mouseInputX = delta.x * dt * mouseSensitivity;
        _mouseInputY = delta.y * dt * mouseSensitivity;

        float camRotateY = transform.localEulerAngles.x;
        camRotateY -= _mouseInputY;

        if (camRotateY > 180f)
            camRotateY -= 360f;
        if (camRotateY > maxRotateY) camRotateY = maxRotateY;
        if (camRotateY < minRotateY) camRotateY = minRotateY;

        // rotate yaw and pitch
        transform.localEulerAngles = new Vector3(
            camRotateY,
            transform.localEulerAngles.y + _mouseInputX,
            0);
    }
}

```

### ActorPhysicsController.cs

```csharp
using UnityEngine;
using UnityEngine.InputSystem;

[RequireComponent(typeof(CharacterController))]
public class ActorPhysicsController : MonoBehaviour
{
    [SerializeField] float jumpPower = 7.5f;
    [SerializeField] float gravityPower = -15f;
    [SerializeField] float speed = 10;
    [SerializeField] float groundedOffset = -0.14f;
    [SerializeField] float groundedRadius = 0.28f;
    [SerializeField] LayerMask groundLayers;
    [SerializeField] Transform camRig;

    CharacterController _characterController;

    float _currentSpeed;
    Vector2 _lookDirection;
    Vector3 _teleportPosition;
    bool _teleportRequest;
    bool _grounded;
    bool _moveLock;
    bool _isJumpInput;

    void Start()
    {
        _characterController = GetComponent<CharacterController>();

        Cursor.lockState = CursorLockMode.Locked;
        Cursor.visible = false;
    }

    public void OnMove(InputAction.CallbackContext context)
    {
        if (context.started)
        {
            _currentSpeed = speed;
            _lookDirection = context.ReadValue<Vector2>();
        }

        if (context.performed)
        {
            _lookDirection = context.ReadValue<Vector2>();
        }

        if (context.canceled)
        {
            _lookDirection = Vector2.zero;
            _currentSpeed = 0;
        }
    }

    public void OnJump(InputAction.CallbackContext context)
    {
        if (context.started &&
            _grounded)
        {
            _isJumpInput = true;
        }
    }

    void Update()
    {
        GroundedCheck();

        MoveByCameraRotate();

        //if button esc, Cursor.lockState change
        if (Input.GetKeyDown(KeyCode.Escape))
        {
            LockMouse();
        }
    }

    void LateUpdate()
    {
        TeleportCheck();
    }

    void GroundedCheck()
    {
        // set sphere position, with offset
        Vector3 spherePosition =
            new Vector3(transform.position.x, transform.position.y - groundedOffset,
                transform.position.z);

        _grounded = Physics.CheckSphere(spherePosition, groundedRadius, groundLayers,
            QueryTriggerInteraction.Ignore);
    }

    void MoveByCameraRotate()
    {
        if (camRig == null)
        {
            Debug.LogError("warnning");
            return;
        }
        var direction =
            camRig.right * _lookDirection.x + camRig.forward * _lookDirection.y;

        direction *= _currentSpeed * Time.deltaTime;

        //move lock
        if (_moveLock)
            direction = Vector3.zero;

        if (_grounded)
        {
            if (direction.y < 0)
                direction.y = -2f;

            if (_isJumpInput)
            {
                _isJumpInput = false;
                direction.y = jumpPower;
            }
        }
        else
        {
            direction.y -= gravityPower * Time.deltaTime;
        }

        // move actor
        _characterController.Move(direction);
    }

    void LockMouse()
    {
        LockMouse(Cursor.lockState != CursorLockMode.Locked);
    }

    void LockMouse(bool value)
    {
        Cursor.lockState = value ? CursorLockMode.Locked : CursorLockMode.None;
        Cursor.visible = !value;
    }

    void TeleportCheck()
    {
        // Check Teleport request
        if (!_teleportRequest)
            return;

        // Do Teleport
        transform.position = _teleportPosition;
        _teleportPosition = Vector3.zero;
    }
}
```

입력 함수들은 UnityEngine.InputSystem을 이용해 받도록 구현하였다. 그 이유는

1. 유니티의 Input System 사용의 장점들을 얻을 수 있다.
  a. 기능 부분과 입력 부분 구현을 분리할 수 있다.
  b. PC의 입력장치로 개발하다가 콘솔 입력 방식을 추가 구현하는 것을 도와준다.
2. 개발한 기능을 다른 Input System을 사용하는 프로젝트에서 사용하기 용이하다.

Input System의 함수를 탐색하는 방식 'SendMessage', 'BroadcastMessage', 'Invoke Unity Events' 중
'Invoke Unity Events'을 선택하여 구현하였다. 그 이유는

1. Rider에서 해당 입력 함수의 참조를 Scene에서 찾을 수 있다. (아래 사진 참고)
2. 다른 두 기능은 해당 함수가 어디서 사용되기 시작하는지 직접적으로 보여주지 못한다. 해당 MonoBehaviour를 사용하고 있는 게임오브젝트에 Player Input 컴포넌트를 보지 않으면 알 수 없다.

![imagename](/assets/image/Unity/FunctionSizeDevelop/CharacterMovementAndCameraControl/Screenshot%202025-04-06%20at%2020.19.17.JPG)


### 개선할 점

카메라 움직임, 캐릭터 움직임 코드들에 각각 입력 기능이 합쳐져 있다.

캐릭터 제어 --<> 카메라 움직임
|
|
<>
캐릭터 움직임

의 구조로 코드를 개선해야 함
